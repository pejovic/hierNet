{
    "collab_server" : "",
    "contents" : "setwd(\"I:/_Bor/drugi rad\")\n\nlibrary(rgdal)\nlibrary(GSIF)\nlibrary(gdalUtils)\nlibrary(raster)\nlibrary(RSAGA)\nlibrary(randomForest)\nlibrary(quantregForest)\nlibrary(plotKML)\nlibrary(plyr)\nlibrary(aqp)\nlibrary(psych)\nlibrary(mda)\nlibrary(classInt)\nlibrary(caret)\nlibrary(randomForest)\nlibrary(forestFloor)\nlibrary(ICEbox)\nlibrary(plotmo)\nlibrary(corrplot)\nlibrary(MASS)\nlibrary(splines)\nlibrary(glmnet)\nlibrary(glinternet)\nlibrary(hierNet)\n\n\ngk_7 <- \"+proj=tmerc +lat_0=0 +lon_0=21 +k=0.9999 +x_0=7500000 +y_0=0 +ellps=bessel +towgs84=574.027,170.175,401.545,4.88786,-0.66524,-13.24673,0.99999311067 +units=m\"\nutm <- \"+proj=utm +zone=34 +ellps=GRS80 +towgs84=0.26901,0.18246,0.06872,-0.01017,0.00893,-0.01172,0.99999996031 +units=m\"\n\n\nload(\"gridmaps.RDa\")\n######################################################################################################################################################\n#######################################################################################################################################################\n\n########### CREATING GRID of COVARIATES  #######################################\n\n#list files\ngrid.list<- dir(path=\"I:/_Bor/drugi rad/Covariates\", pattern=glob2rx(\"*.tif\"), full.names=FALSE)\n\n\n# Read grids into R:\ngridmaps <- readGDAL(paste(getwd(),\"Covariates\",grid.list[1],sep=\"/\"))\nnames(gridmaps)[1]<-sub(\".tif\",\"\",grid.list[1])\n\nfor(i in grid.list[-1]){\n  gridmaps@data[sub(\".tif\",\"\",i[1])]<-readGDAL(paste(getwd(),\"Covariates\",paste(i),sep=\"/\"))$band1\n}\n\nstr(gridmaps)\n\n###########################################################################################\n\ngrid.rast<-brick(gridmaps)\n\n#######################################################################################################################################\n\n#####################################################################################\nclc<-readOGR(dsn=paste(getwd(),\"Covariates\",sep=\"/\"), layer=\"clc06\")\nproj4string(clc)<-proj4string(gridmaps)\n\n\nclc_raster<-rasterize(clc, grid.rast)\nclc.raster<-crop(clc_raster,extent(grid.rast))\ngrid.rast<-addLayer(grid.rast, clc.raster)\n\nstr(grid.rast)\n\ngridmaps<-as(grid.rast,\"SpatialGridDataFrame\")\ngridmaps@data<-gridmaps@data[,-c(19,20,21,22,23,25,26)]\nnames(gridmaps)[19]<-\"clc\"\n\nsm2D.lst<-names(gridmaps)\n\n\n## Soil profiles:\nbor <- join(read.csv(\"Profili_sredjeno_csv.csv\"), read.csv(\"Koordinate_csv.csv\"), type=\"inner\")\nbor$altitude <- -(bor$Top/100+((bor$Bottom - bor$Top)/2)/100)\n## correlation between As and soil properties:\nbor<-bor[,-c(7:12,14,15,16,17)]\nnames(bor)<-c(\"Soil.Type\",\"ID\",\"Horizont\",\"Top\" , \"Bottom\",\"pH\",\"Humus\",\"As\",\"Co\",\"x\",\"y\",\"altitude\")\nsvars <- c(\"pH\",\"Humus\",\"As\",\"Co\")\nc.bor <- bor[complete.cases(bor[,svars]),]\n## 406\nm.Cor <- quantregForest(x=c.bor[,svars[-which(svars==\"Humus\")]], y=c.bor$Humus,importance=TRUE)\nvarImpPlot(m.Cor)\n## TH: \"Humus\" and \"Y1\" are the most important!\n\nbor.xy <- bor[complete.cases(bor[,c(\"ID\",\"x\",\"y\",\"altitude\",\"pH\",\"Humus\",\"As\",\"Co\")]),c(\"ID\",\"x\",\"y\",\"altitude\",\"pH\",\"Humus\",\"As\",\"Co\")] #\"ID\",\"x\",\"y\",\"altitude\",\"pH\",\"Humus\",\"As\",\"Co\"\nbor.xy <- plyr::rename(bor.xy, replace=c(\"x\" = \"longitude\", \"y\" = \"latitude\"))\ncoordinates(bor.xy) <- ~ longitude + latitude\nproj4string(bor.xy) <- CRS(utm)\nbor.xy <- spTransform(bor.xy, CRS(gk_7))\n\n\nbor.Humus.xy <- bor[complete.cases(bor[,c(\"ID\",\"x\",\"y\",\"altitude\",\"Humus\")]),c(\"ID\",\"x\",\"y\",\"altitude\",\"Humus\")] \nbor.Humus.xy <- plyr::rename(bor.Humus.xy, replace=c(\"x\" = \"longitude\", \"y\" = \"latitude\"))\ncoordinates(bor.Humus.xy) <- ~ longitude + latitude\nproj4string(bor.Humus.xy) <- CRS(utm)\nbor.Humus.xy <- spTransform(bor.Humus.xy, CRS(gk_7))\n\n##--------------------- \n## 2D and 3D soil class and soil property mapping\n## TH: There are too many covariates so we reduce to few soil vars;\n##---------------------\n\nbor.soiltype <- bor[unique(bor$ID),c(\"ID\",\"Soil.Type\",\"x\",\"y\")]\nstr(bor.soiltype) ## 206 profiles\ncoordinates(bor.soiltype) <- ~ x + y\nproj4string(bor.soiltype) <- CRS(utm)\n#shape = \"http://maps.google.com/mapfiles/kml/pal2/icon18.png\"\n#kml(bor.soiltype, colour=Soil.Type, file.name=\"bor.soiltype.kml\", shape=shape, size=0.6)\nbor.soiltype <- spTransform(bor.soiltype, CRS(gk_7))\n\n#levels(bor.soiltype$Soil.Type) <- factor(bor.soiltype$Soil.Type)\n\n\n## \ngridmaps.sm2D <- as(gridmaps[sm2D.lst], \"SpatialPixelsDataFrame\")\ngridmaps.sm2D <- gridmaps.sm2D[complete.cases(gridmaps.sm2D@data),]\nstr(gridmaps.sm2D@data) ## 621426 pixels\n\n#gridmaps.sm2D$layer.2_Tip_zemlji <- as.factor(gridmaps.sm2D$layer.2_Tip_zemlji)\ngridmaps2D.spc <- spc(gridmaps.sm2D, as.formula(paste(\"~\", paste(sm2D.lst, collapse=\"+\")))) ## takes few minutes!\nproj4string(gridmaps2D.spc@predicted)<-CRS(gk_7)\nplot(gridmaps2D.spc@pca$sdev)\n## Predict soil types:\nfm.st <- as.formula(paste(\"Soil.Type ~\", paste0(\"PC\", 1:14, collapse=\"+\")))\nm.soiltype <- spmultinom(fm.st, bor.soiltype, gridmaps2D.spc@predicted)\n\ngridmaps.sm2D$SoilType<-m.soiltype@predicted@data$Soil.Type\nproj4string(gridmaps.sm2D)<-CRS(gk_7)\nstr(gridmaps.sm2D)\n\nsave(gridmaps.sm2D,file=\"gridmaps.Rda\")\n#################################################################################################\nbor.profs <- bor[,c(\"ID\",\"x\",\"y\",\"Soil.Type\",\"Top\",\"Bottom\",\"Humus\",\"As\",\"pH\",\"Co\")]\ndepths(bor.profs) <- ID ~ Top + Bottom\nsite(bor.profs) <- ~ Soil.Type + x + y\ncoordinates(bor.profs) <- ~ x+y\nproj4string(bor.profs) <- CRS(utm)\n\n# plot median +/i bounds defined by the 25th and 75th percentiles\n\nagg1<-slab(bor.profs, fm=~ Humus,slab.structure=c(0,5,15,30,60,100,120))\n\n\nxyplot(top ~ p.q50 | variable, data=agg1, ylab='Depth',\n       xlab='median bounded by 25th and 75th percentiles',\n       lower=agg1$p.q25, upper=agg1$p.q75, ylim=c(90,-2),\n       panel=panel.depth_function,\n       alpha=0.25, sync.colors=TRUE,\n       par.settings=list(superpose.line=list(col='RoyalBlue', lwd=2)),\n       prepanel=prepanel.depth_function,\n       cf=agg1$contributing_fraction, cf.col='black', cf.interval=5, \n       layout=c(1,1), strip=strip.custom(bg=grey(0.8)),\n       scales=list(x=list(tick.number=4, alternating=3, relation='free'))\n)\n\n#################################################################################################\nstdepths <- c(-.1,-.3,-1)\nnew3D <- sp3D(gridmaps.sm2D, stdepths=stdepths)\nstr(new3D)\n############# Arsenic 3D prediction #############################################################\n\n############### kopirana grupa od gore ##############################\n## Soil profiles:\nbor <- join(read.csv(\"Profili_sredjeno_csv.csv\"), read.csv(\"Koordinate_csv.csv\"), type=\"inner\")\nbor$altitude <- -(bor$Top/100+((bor$Bottom - bor$Top)/2)/100)\n## correlation between As and soil properties:\nbor<-bor[,-c(7:12,14,15,16,17)]\nnames(bor)<-c(\"Soil.Type\",\"ID\",\"Horizont\",\"Top\" , \"Bottom\",\"pH\",\"Humus\",\"As\",\"Co\",\"x\",\"y\",\"altitude\")\n#svars <- c(\"pH\",\"Humus\",\"As\",\"Co\")\n#c.bor <- bor[complete.cases(bor[,svars]),]\n## 406\n#m.Cor <- quantregForest(x=c.bor[,svars[-which(svars==\"Humus\")]], y=c.bor$Humus,importance=TRUE)\n#varImpPlot(m.Cor)\n## TH: \"Humus\" and \"Y1\" are the most important!\n\nbor.xy <- bor[complete.cases(bor[,c(\"ID\",\"x\",\"y\",\"altitude\",\"pH\",\"Humus\",\"As\",\"Co\")]),c(\"ID\",\"x\",\"y\",\"altitude\",\"pH\",\"Humus\",\"As\",\"Co\")] #\"ID\",\"x\",\"y\",\"altitude\",\"pH\",\"Humus\",\"As\",\"Co\"\nbor.xy <- plyr::rename(bor.xy, replace=c(\"x\" = \"longitude\", \"y\" = \"latitude\"))\ncoordinates(bor.xy) <- ~ longitude + latitude\nproj4string(bor.xy) <- CRS(utm)\nbor.xy <- spTransform(bor.xy, CRS(gk_7))\n\n\nbor.Humus.xy <- bor[complete.cases(bor[,c(\"ID\",\"x\",\"y\",\"altitude\",\"Humus\")]),c(\"ID\",\"x\",\"y\",\"altitude\",\"Humus\")] \nbor.Humus.xy <- plyr::rename(bor.Humus.xy, replace=c(\"x\" = \"longitude\", \"y\" = \"latitude\"))\ncoordinates(bor.Humus.xy) <- ~ longitude + latitude\nproj4string(bor.Humus.xy) <- CRS(utm)\nbor.Humus.xy <- spTransform(bor.Humus.xy, CRS(gk_7))\n\nsm2D.lst<-names(gridmaps.sm2D)[-length(names(gridmaps.sm2D))]\n\n##################################################################3\nov.H <- over(bor.Humus.xy, gridmaps.sm2D)\nbor.Humus.xy@data[,c(sm2D.lst,\"SoilType\")] <- ov.H\nstr(bor.Humus.xy)\n\nbor.Humus.df<-data.frame(bor.Humus.xy)\nbor.Humus.df <- bor.Humus.df[complete.cases(bor.Humus.df[,names(bor.Humus.df)]),]\nstr(bor.Humus.df)\n\n\nnames(bor.Humus.df)\nbor.Humus.df<-bor.Humus.df[,-which(names(bor.Humus.df) %in% c(\"AnalyticalHills\",\"LSFactor\",\"ChannelNetBaseLevel\",\"RelSlopePosition\",\"CatchArea\",\"WindEffectNorthWest\",\"VelleyDepth\",\"optional\"))]\n\n\nstr(bor.Humus.df)\n#bor.Humus.df<-bor.Humus.df[-which(bor.Humus.df$ID %in% c(141)),] #153,137,141,145,150\nsummary(bor.Humus.df)\n#bor.As.df$As\n\nH.df<-ddply(bor.Humus.df,.(altitude))\nH.df <- H.df[order(-H.df$altitude),] \nhead(H.df)\nnames(H.df)\n\n\nsm2D.lst<-names(H.df)[c(4:16)]\n\n\n######################### Partitioning Data - STRATIFICATION #################################\n\n\n\n##############################################################################################\n\n######################### LINEAR MODELS ######################\nfm.H.sp<-as.formula(paste(\"Humus ~\", \"ns(altitude,df=4)\",sep=\"\"))\n\n\nfm.H <- as.formula(paste(\"Humus ~\", paste(c(sm2D.lst,\"altitude\"), collapse=\"+\")))\nfm.H\nfm.int.H<- as.formula(paste(\"Humus ~\",paste(sm2D.lst,\"altitude\",sep=\"*\", collapse=\"+\"),sep=\"\"))\nfm.GSIF.H <- as.formula(paste(\"Humus ~\", paste(c(sm2D.lst,\"ns(altitude,df=4)\"), collapse=\"+\")))\nfm.GSIF.int.H <- as.formula(paste(\"Humus ~\",paste(paste(sm2D.lst,\"altitude\",sep=\"*\" ,collapse=\"+\"),\"ns(altitude,df=4)\",sep=\"+\")))\nfm.GSIF.int.H1 <- as.formula(paste(\"Humus ~\",paste(paste(sm2D.lst,\"poly(altitude,3)\",sep=\"*\",collapse=\"+\"))))\n\nfm.mod.H<-as.formula(\"Humus ~ Aspect + ConvInd + CrossSectCurv + DEM + LongCurv + NegOpenness + \n                      PosOpenness + Slope + TWI + VertDistChannelNet + WindEffectEast + \n                      clc + SoilType + altitude\")\n\n##############################################################################################\n\n\n\n############## GLM NET #######################################################################\n\n\n\npreProcValues <- preProcess(H.df[,c(\"altitude\",sm2D.lst[1:11])], method = c(\"center\", \"scale\"))\nHTrans.df<-cbind(predict(preProcValues, H.df[,c(\"altitude\",sm2D.lst[1:11])]),H.df[,c(2,3)],H.df[,sm2D.lst[12:13]])\nx1 <- model.matrix(fm.H ,HTrans.df)[,-1] #fm.int.lm.As, # fm.GSIF.int.lm.As\nnzv <- nearZeroVar(x1)\nnames(data.frame(x1)[,nzv])\nif(sum(nzv)!=0){x1 <- x1[, -nzv]}else{x1<-x1}\ncorr_mat <- cor(x1)\ntoo_high <- findCorrelation(corr_mat, cutoff = .9)\nif(sum(too_high)!=0){x1 <- x1[, -too_high]}else{x1<-x1}\nhead(x1)\n\nHTrans.df<-x1\nhead(HTrans.df)\nH<-H.df$Humus\n#============= hierNet =============================\n\nhnet<-hierNet(x=HTrans.df[,c(1:19)],y=H,lam=0.3,zz=HTrans.df[,20:34])\n\ncompute.interactions.c(HTrans.df[,c(1:19)],diagonal = FALSE)\nnn<-names(data.frame(compute.interactions.c(HTrans.df[,c(1:19)],diagonal = FALSE)))\nwhich(nn %in% grep(\"altitude\", nn, value = TRUE))\n\n\nhierNet.varimp(hnet,x=HTrans.df[,1:13],y=H)\n\nallData<-cbind(H,HTrans.df,H.df[,c(1,17:18)])\nnames(allData)<-gsub(\"\\\\(altitude,.df.=.4\\\\)\",\"\",names(allData))\n\nH.df.unique<-ddply(allData,.(ID),summarize,Hmean=mean(Humus),longitude=longitude[1],latitude=latitude[1],altitude=min(altitude))\nkm <- kmeans(cbind(scale(H.df.unique$longitude),scale(H.df.unique$latitude),scale(H.df.unique$altitude)), centers = 3)\nplot(H.df.unique$longitude,H.df.unique$latitude, col = km$cluster, pch = 20)\nH.df.unique$km<-as.factor(km$cluster)\n#set.seed(888)\n#IDs<-do.call(c,by(H.df.unique$ID,H.df.unique$km,function(x)  createFolds(x$Hmean, k = 5))\n#length(IDs)\n\nk.list<-as.list(rep(NA,length(unique(H.df.unique$km))))\nnames(k.list)<-paste(\"k\",c(1:length(k.list)),sep=\"\")\n\nfolds=6\n\n#===================== glinternet ======================================================\nY = H.df$Humus\nX = H.df[,c(\"altitude\",sm2D.lst[1:10])]\n\npreProcValues <- preProcess(X, method = c(\"center\", \"scale\"))\nX<-cbind(predict(preProcValues, X))\nhead(X)\n\npreProcValues <- preProcess(X[,1:12], method = c(\"center\", \"scale\"))\nX<-cbind(predict(preProcValues, X[,1:12]),X[,c(13,14)])\n\nX$SoilType<-as.numeric(X$SoilType)\nX$clc<-as.numeric(X$clc)\nX<-as.matrix(X)\nhead(X)\n\nnumLevels = c(rep(1, 11))\nfit = glinternet(X, Y, numLevels=numLevels,numToFind=5,screenLimit=1)\ncoef(fit)\nplot(fit)\n\n########## Creating list of profile indices of 6 folds per cluster region ###############\nfor(i in 1:length(k.list)){\n  set.seed(666)\n  k.list[[i]]<-createFolds(H.df.unique[which(H.df.unique$km==levels(H.df.unique$km)[i]),\"Hmean\"],k=folds)\n    for(j in 1:folds){\n    k.list[[i]][[j]]<-H.df.unique[which(H.df.unique$km==levels(H.df.unique$km)[i]),\"ID\"][k.list[[i]][[j]]]\n      }\n    }\n##########################################################################################\n\n################### Creating list of profile indices per fold ############################\nID.list<-as.list(rep(NA,folds))\nnames(ID.list)<-paste(\"fold\",c(1:folds),sep = \"\")\nfor(i in 1:folds){\n  ID.list[[i]]<-do.call(c,lapply(k.list,function(x) x[[i]]))\n  names(ID.list[[i]])<-NULL\n  #folds.list[[i]]<-as.character(folds.list[[i]])\n  }\n\n###########################################################################################\n#head(allData$ID)\n\n#allData<-ddply(allData,.(ID))\n#head(allData)\n\n##############  Creating list of \nfolds.list<-as.list(rep(NA,folds))\nnames(folds.list)<-paste(\"fold\",c(1:folds),sep = \"\")\nfor(i in 1:length(ID.list)){\n  folds.list[[i]]<-which(allData$ID %in% ID.list[[i]])\n}\n\n\n################### Exploring spatial distribution of folds ##########################\nf1sp<-allData[which(allData$ID %in% folds.list[[1]]),]\nf2sp<-allData[which(allData$ID %in% folds.list[[2]]),]\nf3sp<-allData[which(allData$ID %in% folds.list[[3]]),]\nf4sp<-allData[which(allData$ID %in% folds.list[[4]]),]\nf5sp<-allData[which(allData$ID %in% folds.list[[5]]),]\nf6sp<-allData[which(allData$ID %in% folds.list[[6]]),]\n\nf5sp<-ddply(f5sp,.(ID),H=Humus[1],summarize,longitude=longitude[1],latitude=latitude[1])\ncoordinates(f5sp) <- ~ longitude + latitude\nproj4string(f5sp) <- CRS(gk_7)\nbubble(f5sp,\"H\")\n\n#allData[which(allData$ID %in% folds.list[[2]]),]\n######################################################################################\n\nresults<-data.frame(lambda=rep(NA,length(ID.list)),RMSE=rep(NA,length(ID.list)),Rsquared=rep(NA,length(ID.list)))\nfor(i in 1:length(ID.list)){\n  TrainData<-as.data.frame(do.call(cbind,allData[which(allData$ID %in% do.call(c,ID.list[-i])),]))\n  Train.ID.index<-ID.list[-i]\n  TestData<-as.data.frame(do.call(cbind,allData[which(allData$ID %in% do.call(c,ID.list[i])),]))\n  Test.ID.Index<-ID.list[i]\n  \n  folds1<-length(Train.ID.index)\n  folds.list1<-as.list(rep(NA,folds1))\n  names(folds.list1)<-paste(\"fold\",c(1:folds1),sep = \"\")\n  foldid<-rep(NA,dim(TrainData)[1])\n  for(j in 1:length(Train.ID.index)){\n    folds.list1[[j]]<-which(TrainData$ID %in% Train.ID.index[[j]])\n    foldid[folds.list1[[j]]]<-j\n    }\n  \n  TrainData<-TrainData[,1:(dim(TrainData)[2]-3)]\n  TestData<-TestData[,1:(dim(TestData)[2]-3)]\n  lambdaGrid <- seq(0,2.5,0.05)#10^seq(10,-2, length =100)\n  lasso.mod=cv.glmnet(as.matrix(TrainData[,-1]),TrainData[,1],alpha=1,lambda=lambdaGrid,foldid=foldid,type.measure=\"mse\")\n  lasso.pred<-predict(lasso.mod,s=lasso.mod$lambda.min,newx=as.matrix(TestData[,-1]))\n  obs.pred<-data.frame(obs=TestData$H,pred=as.numeric(lasso.pred))\n  dfresults<-data.frame(lambda=lasso.mod$lambda.min,RMSE=defaultSummary(obs.pred)[1],Rsquared=defaultSummary(obs.pred)[2])\n  results[i,]<-dfresults\n}\n\nH.GSIF.int.fm.results<-results\nH.GSIF.fm.results<-results  \nH.fm.results<-results\nH.int.fm.results<-results\n\n\n###################### stratFold3D #######################################  \n\n\nstratFold3D<-function(targetVar,regdat,folds=6,cent=3,preProc=TRUE,seed=666,dimensions=list(\"2D\",\"3D\"),IDs=TRUE,sum=FALSE,plot=FALSE){\n  \n  dimensions<-dimensions[[1]]\n  if(dimensions==\"2D\"){\n  \n  unique.df<-ddply(regdat,.(ID),here(summarize),target=mean(eval(parse(text=targetVar))),longitude=longitude[1],latitude=latitude[1])\n  km <- kmeans(cbind(unique.df$longitude,unique.df$latitude), centers = cent)\n  #plot(unique.df$longitude,unique.df$latitude, col = km$cluster, pch = 20)\n  unique.df$km<-as.factor(km$cluster)} else {\n    \n    unique.df<-ddply(regdat,.(ID),here(summarize),target=mean(eval(parse(text=targetVar))),longitude=longitude[1],latitude=latitude[1],altitude=min(altitude))\n    km <- kmeans(cbind(scale(unique.df$longitude),scale(unique.df$latitude),scale(unique.df$altitude)), centers = cent)\n    #plot(unique.df$longitude,unique.df$latitude, col = km$cluster, pch = 20)\n    unique.df$km<-as.factor(km$cluster)\n  }\n  \n  \n  k.list<-as.list(rep(NA,length(unique(unique.df$km))))\n  names(k.list)<-paste(\"k\",c(1:length(k.list)),sep=\"\")\n  \n\n  ########## Creating list of profile indices of 6 folds per cluster region ###############\n  for(i in 1:length(k.list)){\n    set.seed(seed)\n    k.list[[i]]<-createFolds(unique.df[which(unique.df$km==levels(unique.df$km)[i]),\"target\"],k=folds)\n    for(j in 1:folds){\n      k.list[[i]][[j]]<-unique.df[which(unique.df$km==levels(unique.df$km)[i]),\"ID\"][k.list[[i]][[j]]]\n    }\n  }\n  ##########################################################################################\n  \n  ################### Creating list of profile indices per fold ############################\n  ID.list<-as.list(rep(NA,folds))\n  names(ID.list)<-paste(\"fold\",c(1:folds),sep = \"\")\n  for(i in 1:folds){\n    ID.list[[i]]<-do.call(c,lapply(k.list,function(x) x[[i]]))\n    names(ID.list[[i]])<-NULL\n    #folds.list[[i]]<-as.character(folds.list[[i]])\n  }\n  \n  ###########################################################################################\n  \n  ##############  Creating list of \n  folds.list<-as.list(rep(NA,folds))\n  names(folds.list)<-paste(\"fold\",c(1:folds),sep = \"\")\n  for(i in 1:length(ID.list)){\n    folds.list[[i]]<-which(regdat$ID %in% ID.list[[i]])\n  }\n  \n  \n  pom<-data.frame()\n  for(i in 1:length(folds.list)){\n    allData1<-regdat[folds.list[[i]],]\n    allData1$fold<-paste(\"fold\",i,sep=\"\")\n    allData<-rbind(allData1,pom)\n    pom<-allData\n  }\n  allData$fold<-factor(allData$fold)\n  sum.list=list(by(allData$altitude,allData$fold,summary))\n  if(IDs==TRUE){index.list=(ID.list)}else{index.list=(folds.list)}\n  sum.list<-list(allData,index.list,sum.list,by(allData[,paste(targetVar)],allData$fold,summary))\n  names(sum.list)<-c(\"Data\",\"folds\",\"altitude summary\",paste(targetVar,\"summary\", sep=\" \"))\n  \n  if(plot==TRUE){\n\n    allData.unique<-ddply(allData,.(ID),here(summarize),target=mean(eval(parse(text=targetVar))),longitude=longitude[1],latitude=latitude[1],fold=fold[1])\n    q <- ggplot(allData.unique,aes(x = longitude, y = latitude))\n    r <- q +geom_point(aes(size = sqrt(target/pi)), pch = 21, show.legend = FALSE) + scale_size_continuous(range=c(1,10))\n    r <- r + facet_wrap(~ fold)\n    r<-r + aes(fill = fold)\n    plot(r)\n  }\n  \n  if(sum==TRUE){return(sum.list)}else{return(sum.list[[1]])}\n}\n\n# Treba dodati opciju za parametar za stratifikaciju (dubinu) tj. da li je strat=2D or 3D OK\n# Treba dodati summary za foldove (za prostor i za target variable)\n# Treba dodati opciju za plot foldova sa odabranim parametrom\n# Podeliti funkciju tako da se radi odvojena stratifikacija za nested cv\n\n\nstrat<-stratFold3D(targetVar=\"Humus\",regdat=H.df,folds=4,cent=3,dimensions=\"2D\",IDs=TRUE,sum=TRUE,plot=TRUE)\nflist<-strat$folds\n\npenint3D<-function(regdat,contvar,folds=4,c=3,lambda=seq(0,2.5,0.05),)  \n  \nlasso.coef=predict(lasso.mod,type=\"coefficients\",s=lasso.mod$lambda.min)\n  \n#===============================================================================================\nfm.H <- as.formula(paste(\"Humus ~\", paste(c(sm2D.lst,\"altitude\"), collapse=\"+\")))\nfm.int.H<- as.formula(paste(\"Humus ~\",paste(sm2D.lst,\"altitude\",sep=\"*\", collapse=\"+\"),sep=\"\"))\nfm.GSIF.H <- as.formula(paste(\"Humus ~\", paste(c(sm2D.lst,\"ns(altitude,df=4)\"), collapse=\"+\")))\nfm.GSIF.int.H <- as.formula(paste(\"Humus ~\",paste(paste(sm2D.lst,\"altitude\",sep=\"*\" ,collapse=\"+\"),\"ns(altitude,df=4)\",sep=\"+\")))\nfm.GSIF.int.H1 <- as.formula(paste(\"Humus ~\",paste(paste(sm2D.lst,\"poly(altitude,3)\",sep=\"*\",collapse=\"+\"))))\n#===============================================================================================\n\nfun<-fm.H\nregdat<-H.df\ncontVar<-sm2D.lst[1:11]\ntargetVar<-\"Humus\"\n\npenint3D<-function(fun,regdat,contVar,flist,lambda=seq(0,5,0.1),int=TRUE,depth.fun=list(\"linear\",\"nspline\",\"poly\"),df=4,deg=3,preProc=TRUE){\n  \n  tvar<-as.character(fun)[2]\n  covs<-gsub(\"[[:space:]]\", \"\", as.character(fun)[3])\n  covs<-unlist(strsplit(covs, \"+\", fixed = TRUE))\n  depth<-covs[length(covs)]\n  covs<-covs[-length(covs)]\n  \n\n    if(int==TRUE){\n    fun<-as.formula(paste(tvar, \"~\" ,paste(covs,depth,sep=\"*\", collapse=\"+\"),sep=\"\"))\n    } else {fun<-fun}\n\n  \n  \n  if(preProc==TRUE){\n    preProcValues <- preProcess(regdat[,contVar], method = c(\"center\", \"scale\"))\n    Trans.df<-cbind(predict(preProcValues, regdat[,contVar]),regdat[,-which(names(regdat) %in% contVar)])\n  }\n\n    modmat <- model.matrix(fun ,Trans.df)[,-1] #fm.int.lm.As, # fm.GSIF.int.lm.As\n    # removing nzv varaibles \n    nzv <- nearZeroVar(modmat)\n    if(sum(nzv)!=0){modmat <- modmat[, -nzv]}else{modmat<-modmat}\n\n    # removing correlated variables \n    corr_mat <- cor(modmat)\n    too_high <- findCorrelation(corr_mat, cutoff = .9)\n    if(sum(too_high)!=0){modmat <- modmat[, -too_high]}else{modmat<-modmat}\n\n\n    allData<-cbind(regdat[,paste(tvar)],modmat,regdat[,c(\"ID\",\"longitude\",\"latitude\")])\n    names(allData)<-gsub(\"\\\\(altitude,.df.=.4\\\\)\",\"\",names(allData))\n\n    results<-data.frame(lambda=rep(NA,length(flist)),RMSE=rep(NA,length(flist)),Rsquared=rep(NA,length(flist)))\n    coef.list=as.list(rep(NA,length(strat)))\n    for(i in 1:length(flist)){\n      ind<-which(allData$ID %in% do.call(c,flist[-i]))\n      TrainData<-as.data.frame(do.call(cbind,allData[ind,]))\n      Train.ID.index<-flist[-i]\n      TestData<-as.data.frame(do.call(cbind,allData[ind,]))\n      Test.ID.Index<-flist[i]\n      \n      folds1<-length(Train.ID.index)\n      folds.list1<-as.list(rep(NA,folds1))\n      names(folds.list1)<-paste(\"fold\",c(1:folds1),sep = \"\")\n      foldid<-rep(NA,dim(TrainData)[1])\n      for(j in 1:length(Train.ID.index)){\n        folds.list1[[j]]<-which(TrainData$ID %in% Train.ID.index[[j]])\n        foldid[folds.list1[[j]]]<-j\n      }\n      \n      TrainData<-TrainData[,1:(dim(TrainData)[2]-3)]\n      TestData<-TestData[,1:(dim(TestData)[2]-3)]\n      #lambdaGrid <- seq(0,2.5,0.05)#10^seq(10,-2, length =100)\n      lasso.mod=cv.glmnet(as.matrix(TrainData[,-1]),TrainData[,1],alpha=1,lambda=lambda,foldid=foldid,type.measure=\"mse\")\n      lasso.pred<-predict(lasso.mod,s=lasso.mod$lambda.min,newx=as.matrix(TestData[,-1]))\n      obs.pred<-data.frame(obs=TestData[,1],pred=as.numeric(lasso.pred))\n      coef.list[[i]]<-predict(lasso.mod,type=\"coefficients\",s=lasso.mod$lambda.min)\n      dfresults<-data.frame(lambda=lasso.mod$lambda.min,RMSE=defaultSummary(obs.pred)[1],Rsquared=defaultSummary(obs.pred)[2])\n      results[i,]<-dfresults\n    }\n    coef.mat<-do.call(cbind,coef.list)\n    out<-list(measure=results,coef=coef.mat)\n    return(out)\n    }\n\n# Napraviti opciju da od pocetnog modela pravi model sa interakcijama\n# Napraviti opciju za modeliranje vertikalnog trenda (spline, poly, ... )\n# Izbor modela\n# Skladistenje residuala i predikcije\n# \n\nfun<-fm.H\nregdat<-H.df\ncontVar<-sm2D.lst[1:11]\ntargetVar<-\"Humus\"\n\nstrat<-stratFold3D(targetVar=\"Humus\",regdat=H.df,folds=6,cent=3,dimensions=\"2D\",IDs=TRUE,sum=TRUE,plot=TRUE)\nflist<-strat$folds\npenint3D(fun=fm.H,regdat=H.df,lambda=10^seq(10,-2,length=100),contVar=sm2D.lst[1:11],int=TRUE,flist=flist)\n\n\ngrid=10^seq(10,-2, length =100)\n\nInt.train<- train(TrainData[,-1],TrainData[,1],method='glmnet',\n                  trControl= trainControl(method = \"cv\", index = folds.list1),\n                  tuneGrid = lambdaGrid,\n                  metric=\"RMSE\"\n\n\n\n\n\n\n\n\n\n\n\nH.df.unique[which(H.df.unique$km==levels(H.df.unique$km)[i]),\"ID\"][k.list[[i]][[j]]]\nk.list[[1]]\n\n\n\nlapply(k.list,function(x) lapply(x,function(y) H.df.unique[which(H.df.unique$km==levels(H.df.unique$km)[i]),\"ID\"]))\n\ncreateFolds(H.df.unique[which(H.df.unique$km==levels(H.df.unique$km)[1]),\"Hmean\"],k=3)\n\n\nflds <- createFolds(allData$H, k = 5, list = TRUE, returnTrain = FALSE)\nnames(flds)[1] <- \"train\"\n\n\nxtrain<-HTrans.df[-which(H.df$ID %in% IDs),]\nxtest<-HTrans.df[which(H.df$ID %in% IDs),]\nnames(allData)<-gsub(\" \",\".\",names(allData))\nnames(allData)<-gsub(\"\\\\(altitude,.df.=.4\\\\)\",\"\",names(allData))\n\n\n\n\nYtrain <- data.frame(Humus=HTrain$Humus)\nYtest <- data.frame(Humus=HTest$Humus)\n\n\n\ntrain.data<-cbind(Ytrain,xtrain)\ntest.data<-cbind(Ytest,xtest)\n\n\n\n\n\n\nH.df.unique<-ddply(H.df,.(ID),Humus=Humus[1],summarize,longitude=longitude[1],latitude=latitude[1])\nkm <- kmeans(cbind(H.df.unique$longitude,H.df.unique$latitude,H.df.unique$As*10), centers = 4)\nplot(H.df.unique$longitude,H.df.unique$latitude, col = km$cluster, pch = 20)\nH.df.unique$km<-as.factor(km$cluster)\nset.seed(888)\nIDs<-do.call(c,by(H.df.unique$ID,H.df.unique$km,function(x) sample(x,round(length(x)*30/100))))\nlength(IDs)\n\nHTrain<-H.df[-which(H.df$ID %in% IDs),]\nHTest<-H.df[which(H.df$ID %in% IDs),]\n\nSpHTrain<-ddply(HTrain,.(ID),Humus=Humus[1],summarize,longitude=longitude[1],latitude=latitude[1])\ncoordinates(SpHTrain) <- ~ longitude + latitude\nproj4string(SpHTrain) <- CRS(gk_7)\n\nbubble(SpHTrain,\"Humus\")\n\nSpHTest<-HTest\ncoordinates(SpHTest) <- ~ longitude + latitude\nproj4string(SpHTest) <- CRS(gk_7)\nbubble(SpHTest,\"Humus\")\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1457282395205.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1521185299",
    "id" : "8BFA15F0",
    "lastKnownWriteTime" : 1457218977,
    "last_content_update" : 1457218977,
    "path" : "I:/_Bor/Drugi rad/HumusExtensionsPenal.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}