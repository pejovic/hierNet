{
    "collab_server" : "",
    "contents" : "hierNet <- function(x, y, lam, delta=1e-8, strong=FALSE, diagonal=TRUE, aa=NULL, zz=NULL, center=TRUE, stand.main=TRUE, stand.int=FALSE, \n                    rho=nrow(x), niter=100, sym.eps=1e-3,\n                    step=1, maxiter=2000, backtrack=0.2, tol=1e-5,\n                    trace=0) {\n  # Main Hiernet function for fitting at a single parameter lambda.\n  # Note: L1 penalty terms have parameter lam.l1 = lambda * (1-delta)\n  #       and L2 penalty has parameter lam.l2 = lambda * delta.\n  #\n  # stand.main and stand.int refer to scaling\n  stopifnot(nrow(x) == length(y), lam >= 0, delta >= 0, delta <= 1)\n  stopifnot(!is.null(step) && !is.null(maxiter))\n  if (strong) stopifnot(!is.null(niter))\n  stopifnot(class(y) == \"numeric\")\n  stopifnot(class(lam) == \"numeric\")\n  stopifnot(class(delta) == \"numeric\")\n  stopifnot(class(step) == \"numeric\", step > 0, maxiter > 0)\n  stopifnot(is.finite(x), is.finite(y), is.finite(lam), is.finite(delta))\n  this.call <- match.call()\n\n  if (!center) cat(\"WARNING: center=FALSE should almost never be used.  This option is available for special uses only.\", fill=TRUE)\n  # center and (maybe) scale variables\n  x <- scale(x, center=center, scale=stand.main)\n  mx <- attr(x, \"scaled:center\")\n  sx <- attr(x, \"scaled:scale\") # may be NULL\n  if (center) {\n    my <- mean(y)\n    y <- y - my\n  } else my <- NULL\n  \n  if (is.null(zz)) {\n    if (trace > 0) cat(\"Computing zz...\", fill=TRUE)\n    zz <- compute.interactions.c(x, diagonal=diagonal)\n  }\n  if (is.matrix(zz)) {\n    zz <- scale(zz, center=center, scale=stand.int)\n    mzz <- attr(zz, \"scaled:center\")\n    szz <- attr(zz, \"scaled:scale\") # may be NULL\n    zz <- as.numeric(zz)\n  } else {\n    mzz <- szz <- NULL\n    #cat(\"Provided zz is not a matrix, so it's assumed to be already centered.\", fill=TRUE)\n  }\n\n  xnum <- as.numeric(x)\n  p <- ncol(x)\n  lam.l1 <- lam * (1 - delta)\n  lam.l2 <- lam * delta\n  if (strong) {\n    # strong hierarchy -- use ADMM4\n    if (is.null(rho)) rho <- as.numeric(nrow(x))\n    stopifnot(is.numeric(rho), is.finite(rho))\n    aa <- admm4(x, xnum, y, lam.l1=lam.l1, lam.l2=lam.l2, diagonal=diagonal, zz=zz,\n                 rho=rho, niter=niter, aa=aa, sym.eps=sym.eps, # ADMM params\n                 stepsize=step, backtrack=backtrack, maxiter=maxiter, tol=tol, # GG params\n                 trace=trace)\n    # lack of symmetry in theta means that sometimes strong hierarchy will be (very slightly violated)\n    ii <- aa$bp + aa$bn == 0\n    # note aa$th[ii, ] = 0 since weak hierarchy holds for sure\n    if (sum(ii) > 0 & sum(ii) < p) {\n      thr <- max(abs(aa$th[!ii, ii]))\n      if (thr > 0) {\n        cat(\"  thr = \",thr, fill=TRUE)\n        if (thr > 1e-3)\n          warning(\"Had to change ADMM's 'th' by more than 0.001 to make strong hier hold! Increase niter (and/or rho). \")\n        aa$th[abs(aa$th) <= thr] <- 0\n      }\n    }\n  } else {\n    # weak hierarchy -- a single call to generalized gradient descent\n    if (is.null(aa)) {\n      aa <- list(th=matrix(0, p, p), bp=rep(0, p), bn=rep(0, p))\n    } else {\n      stopifnot(dim(aa$th) == c(p,p), length(aa$bp) == p, length(aa$bn) == p)\n    }\n    # this could be improved by not actually creating V...\n    V <- matrix(0, p, p)\n    rho <- 0\n    aa <- ggdescent.c(x=x, xnum=xnum, zz=zz, y=y, lam.l1=lam.l1, lam.l2=lam.l2, diagonal=diagonal,\n       \t  \t      rho=rho, V=V,\n                      stepsize=step, backtrack=backtrack, maxiter=maxiter, tol=tol,\n                      aa=aa, trace=trace)\n  }\n\n  aa$lam <- lam\n  aa$delta <- delta\n  aa$type <- \"gaussian\"\n  aa$diagonal <- diagonal\n  aa$strong <- strong\n  aa$obj <- Objective(aa=aa, x=x, y=y, lam.l1=lam.l1, lam.l2=lam.l2, xnum=xnum, zz=zz, strong=strong)\n  aa$step <- step\n  aa$maxiter <- maxiter\n  aa$backtrack <- backtrack\n  aa$tol <- tol\n  if (strong) {\n    # ADMM parameters:\n    aa$rho <- rho\n    aa$niter <- niter\n    aa$sym.eps <- sym.eps\n  }\n  aa$mx <- mx\n  aa$sx <- sx\n  aa$my <- my\n  aa$mzz <- mzz\n  aa$szz <- szz\n  aa$call <- this.call\n  class(aa) <- \"hierNet\"\n  return(aa)\n}\n\nprint.hierNet <- function(x, ...) {\n  cat(\"Call:\\n\")\n  dput(x$call)\n  th=(x$th+t(x$th))/2\n  o2=colSums(th^2)!=0\n  b=x$bp-x$bn\n  o=b!=0\n  b=b[o]\n  if (any(o2)) {\n    # model has interactions\n    th=th[o,o2,drop=FALSE]\n    tight <- rowSums(abs(th)) >= x$bp[o] + x$bn[o] - 1e-9\n    tt <- rep(\"\", length(tight))\n    tt[tight] <- \"*\"\n    mat=cbind(b,th)\n    mat=round(mat,4)\n    mat <- cbind(mat, tt)\n    cat(\"\\n\")\n    cat(\"Non-zero coefficients:\",fill=T)\n    cat(\"  (Rows are predictors with nonzero main effects)\",fill=T)\n    cat(\"  (1st column is main effect)\", fill=T)\n    cat(\"  (Next columns are nonzero interactions of row predictor)\", fill=T)\n    cat(\"  (Last column indicates whether hierarchy constraint is tight.)\",fill=T)\n    cat(\"\\n\")\n    dimnames(mat)=list(as.character(which(o)),c(\"Main effect\",as.character(which(o2)),\"Tight?\"))\n    print(mat, quote = FALSE)\n  } else {\n    mat <- matrix(round(b,4), length(b), 1)\n    cat(\"\\n\")\n    cat(\"Non-zero coefficients:\",fill=T)\n    cat(\"  (No interactions in this model)\",fill=T)\n    cat(\"\\n\")\n    dimnames(mat)=list(as.character(which(o)),\"Main effect\")\n    print(mat, quote = FALSE)    \n  }\n  invisible()\n}\n\nprint.hierNet.path <- function(x, ...) {\n  cat(\"Call:\\n\")\n  dput(x$call)\n  b=x$bp-x$bn\n  mat=cbind(round(x$lam,2),round(x$obj,2),colSums(b!=0),apply(x$th!=0,3,function(a) sum(diag(a)) + sum((a+t(a)!=0)[upper.tri(a)])))\n\n  dimnames(mat)=list(NULL,c(\"Lambda\", \"Objective\", \"Number of main effects\",\"Number of interactions\"))\n  cat(\"\\n\")\n  print(mat, quote = FALSE)\n  invisible()\n}\n\nprint.hierNet.cv <- function(x, ...) {\n  cat(\"Call:\\n\")\n  dput(x$call)\nmat=cbind(round(x$lamlist,2),x$nonzero,round(x$cv.err,2),round(x$cv.se,2))\n\n  dimnames(mat)=list(NULL,c(\"Lambda\", \"Number of nonzero\",\"Mean CV error\", \"SE\"))\n cat(\"\\n\")\n  print(mat, quote = FALSE)\n cat(\"\\n\")\ncat(c(\"lamhat=\",round(x$lamhat,2),\"lamhat.1se=\",round(x$lamhat.1se,2)),fill=T)\n\n  invisible()\n}\n\n\nhierNet.path <- function(x, y, lamlist=NULL, delta=1e-8, minlam=NULL, maxlam=NULL, nlam=20, flmin=.01,\n                         diagonal=TRUE, strong=FALSE, aa=NULL, zz=NULL,\n                         stand.main=TRUE, stand.int=FALSE,\n                         rho=nrow(x), niter=100, sym.eps=1e-3,# ADMM params\n                         step=1, maxiter=2000, backtrack=0.2, tol=1e-5, # GG descent params\n                         trace=0) {\n  # Main Hiernet function for fitting at a sequence of lambda values.\n  # Note: L1 penalty terms have parameter lam.l1 = lambda * (1-delta)\n  #       and L2 penalty has parameter lam.l2 = lambda * delta.\n  #\n  # Always centers both x and zz (unless zz is provided in as.numeric form)\n  # stand.main and stand.int refer to whether main effects and interactions should have norm sqrt(n-1)\n  \n  # center and (maybe) scale variables\n  this.call <- match.call()\n  x <- scale(x, center=TRUE, scale=stand.main)\n  mx <- attr(x, \"scaled:center\")\n  sx <- attr(x, \"scaled:scale\") # may be NULL\n  my <- mean(y)\n  y <- y - my\n  \n  if (is.null(maxlam)) {\n    if (!is.null(minlam)) stop(\"Cannot have maxlam=NULL if minlam is non-null.\")\n  #  maxlam <- max(abs(t(x) %*% y)/colSums(x^2))\n    maxlam <- max(abs(t(x) %*% y))\n  #  temp <- t(scale(t(x), center=FALSE, scale=1/y))\n  #  temp2 <- apply(temp, 2, twonorm)\n  #  maxlam <- max(max(temp2), maxlam)\n    minlam <- maxlam * flmin\n  }\n  if (is.null(minlam)) minlam <- maxlam * flmin\n  if (is.null(lamlist))\n    lamlist <- exp(seq(log(maxlam),log(minlam),length=nlam))\n  nlam <- length(lamlist)\n  \n  if (is.null(zz))\n    zz <- compute.interactions.c(x, diagonal=diagonal)\n  else\n    stopifnot(is.matrix(zz))\n  \n  # center and (maybe) scale zz\n  zz <- scale(zz, center=TRUE, scale=stand.int)\n  mzz <- attr(zz, \"scaled:center\")\n  szz <- attr(zz, \"scaled:scale\") # may be NULL\n  \n  zz <- as.numeric(zz)\n  p <- ncol(x)\n  cp2 <- choose(p, 2)\n  bp <- bn <- matrix(NA, nrow=p, ncol=nlam)\n  th <- array(NA, c(p, p, nlam))\n  obj <- rep(NA, nlam)\n  aa <- NULL\n  for (i in seq(nlam)) {\n    cat(c(\"i,lam=\", i, round(lamlist[i],2)), fill=TRUE)\n    aa <- hierNet(x, y, lam=lamlist[i], delta=delta, strong=strong, diagonal=diagonal, aa=aa, zz=zz,\n                  stand.main=FALSE, stand.int=FALSE, # have already standardized\n                  rho=rho, niter=niter, sym.eps=sym.eps,\n                  step=step, maxiter=maxiter, backtrack=backtrack, tol=tol, trace=trace)\n    bp[, i] <- aa$bp\n    bn[, i] <- aa$bn\n    th[, , i] <- aa$th\n    obj[i] <- aa$obj\n  }\n  dimnames(bp) <- dimnames(bn) <- list(as.character(1:p), NULL)\n  dimnames(th) <- list(as.character(1:p), as.character(1:p), NULL)\n\n  out <- list(bp=bp, bn=bn, th=th, obj=obj, lamlist=lamlist, delta=delta, mx=mx, sx=sx, mzz=mzz, szz=szz, my=my,\n              type=\"gaussian\", diagonal=diagonal, strong=strong,\n              step=step, maxiter=maxiter, backtrack=backtrack, tol=tol,    \n              call=this.call)\n  if (strong) {\n    # ADMM parameters:\n    out$rho <- rho\n    out$niter <- niter\n    out$sym.eps <- sym.eps\n  }\n  class(out) <- \"hierNet.path\"\n  out\n}\n\npredict.hierNet <- function(object, newx, newzz=NULL, ...) {\n  n <- nrow(newx)\n  if (is.null(object$sx))\n    newx <- scale(newx, center=object$mx, scale=FALSE)\n  else\n    newx <- scale(newx, center=object$mx, scale=object$sx)    \n  if (is.null(newzz))\n    newzz <- compute.interactions.c(newx, diagonal=object$diagonal)\n  if (is.null(object$szz))\n    newzz <- scale(newzz, center=object$mzz, scale=FALSE)\n  else\n    newzz <- scale(newzz, center=object$mzz, scale=object$szz)\n  newzz <- as.numeric(newzz)\n  newx <- as.numeric(newx)\n  stopifnot(is.finite(newzz), is.finite(newx))\n  if (class(object$bp) == \"numeric\")\n    yhatt <- Compute.yhat.c(newx, newzz, object) + object$my\n  else {\n    nlam <- ncol(object$bp)\n    yhat <- matrix(NA, n, nlam)\n    # this could be made more efficient\n    for (i in seq(nlam)) {\n      bb <- list(bp=object$bp[, i], bn=object$bn[, i], th=object$th[, , i], diagonal=object$diagonal)\n      yhat[, i] <- Compute.yhat.c(newx, newzz, bb)\n    }\n    yhatt <- yhat + object$my\n  }\n  if (object$type == \"logistic\") {\n    # predict from hierNet.logistic object object\n    b0 <- object$b0\n    if(is.matrix(yhatt))\n      b0 <- matrix(b0, nrow=nrow(yhatt), ncol=ncol(yhatt), byrow=T)\n    yhatt <- b0 + yhatt\n    pr <- 1 / (1 + exp(-yhatt))\n    return(list(prob=pr, yhat=1*(pr>.5)))\n  }\n  return(yhatt)\n}\n\npredict.hierNet.path <- function(object, newx, newzz=NULL, ...){\n predict.hierNet(object, newx, newzz, ...)\n}\n\nadmm4 <- function(x, xnum, y, lam.l1, lam.l2, diagonal, zz=NULL, rho, niter, aa=NULL, sym.eps=1e-3, trace=1, ...) {\n  # Performs ADMM4.\n  # Note: xnum is the matrix x as a numeric.  Both are passed to avoid having to call as.numeric too\n  # many times.\n  p <- ncol(x)\n  if (is.null(zz)) {\n    if (trace > 0) cat(\"Computing zz...\", fill=TRUE)\n    zz <- as.numeric(compute.interactions.c(x, diagonal=diagonal))\n  }\n  else if (class(zz) == \"matrix\") zz <- as.numeric(zz)\n  if (is.null(aa)) {\n    aa <- list(u=matrix(0, p, p),\n               th=matrix(0, p, p),\n               bp=rep(0, p),\n               bn=rep(0, p),\n               tt=matrix(0, p, p),\n               diagonal=diagonal)\n  } else {\n    stopifnot(diagonal == aa$diagonal)\n  }\n  if (is.null(aa$tt) || is.null(aa$u)) {\n    aa$tt <- 0.5 * (aa$th + t(aa$th))\n    aa$u <- matrix(0, p, p)\n  }\n  obj <- Objective(aa=aa, x=x, y=y, lam.l1=lam.l1, lam.l2=lam.l2, xnum=xnum, zz=zz, strong=TRUE, sym.eps=sym.eps)\n  ll <- NULL\n  for (i in seq(niter)) {\n    if (trace > 0) cat(i, \" \")\n    ll <- c(ll, ADMM4.Lagrangian(aa, xnum, zz, y, lam.l1=lam.l1, lam.l2=lam.l2, diagonal=diagonal, rho))\n    V <- aa$u - rho * aa$tt\n    gg <- ggdescent.c(x, xnum, zz, y, lam.l1=lam.l1, lam.l2=lam.l2, diagonal=diagonal, rho, V, trace=trace-1, aa=aa, ...)\n    aa$th <- gg$th\n    aa$bp <- gg$bp\n    aa$bn <- gg$bn\n    aa$tt <- (aa$th + t(aa$th)) / 2 + (aa$u + t(aa$u)) / (2 * rho)\n    aa$u <- aa$u + rho * (aa$th - aa$tt)\n    obj <- c(obj, Objective(aa=aa, x=x, y=y, lam.l1=lam.l1, lam.l2=lam.l2, xnum=xnum, zz=zz, strong=TRUE, sym.eps=sym.eps))\n    if (trace > 0) cat(obj[i+1], fill=TRUE)\n  }\n  if (max(abs(aa$th-t(aa$th))) > sym.eps)\n    cat(\"Attention: th not symmetric within the desired sym.eps.  Run ADMM for more iterations. And try increasing rho.\")\n  aa$obj <- obj\n  aa$lagr <- ll\n  aa\n}\n\nObjective <- function(aa, x, y, lam.l1, lam.l2, xnum=NULL, zz=NULL, strong=TRUE, sym.eps=1e-3) {\n  # evaluates the NewYal objective at aa.\n  if (strong) {\n    if (max(aa$th-t(aa$th)) > sym.eps) {\n      cat(\"Theta is not symmetric.\", fill=TRUE)\n      return(Inf)\n    }\n  }\n  if (any(rowSums(abs(aa$th)) > aa$bp + aa$bn + 1e-5)) {\n    cat(\"hierarchy violated.\", fill=TRUE)\n    return(Inf)\n  }\n  if (any(aa$bp < -1e-5)||any(aa$bn < -1e-5)) {\n    cat(\"Non-negative of bp or bn violated.\", fill=TRUE)\n    return(Inf)\n  }\n  if (aa$diagonal == FALSE)\n    if (any(abs(diag(aa$th)) > 1e-8)) {\n      cat(\"Zero diagonal violated.\", fill=TRUE)\n      return(Inf)\n    }\n  if (is.null(zz)) {\n    zz <- as.numeric(compute.interactions.c(x, diagonal=aa$diagonal))\n  }\n  if (is.null(xnum)) xnum <- as.numeric(x)\n  r <- y - Compute.yhat.c(xnum, zz, aa)\n  pen <- lam.l1 * sum(aa$bp + aa$bn) + lam.l1 * sum(abs(aa$th))/2 + lam.l1 * sum(abs(diag(aa$th)))/2\n  pen <- pen + lam.l2 * (sum(aa$bp^2) + sum(aa$bn^2) + sum(aa$th^2))\n  sum(r^2)/2 + pen\n}\n\nObjective.logistic <- function(aa, x, y, lam.l1, lam.l2, xnum=NULL, zz=NULL, strong=TRUE, sym.eps=1e-3) {\n  # evaluates the logistic hiernet objective at aa.\n  stopifnot(y %in% c(0,1))\n  stopifnot(\"diagonal\" %in% names(aa))\n  if (aa$diagonal == FALSE)\n    if (any(abs(diag(aa$th)) > 1e-8)) {\n      cat(\"Diagonal of Theta is nonzero.\", fill=TRUE)\n      return(Inf)\n    }\n  if (strong) {\n    if (max(aa$th-t(aa$th)) > sym.eps) {\n      cat(\"Theta is not symmetric.\", fill=TRUE)\n      return(Inf)\n    }\n  }\n  if (any(rowSums(abs(aa$th)) > aa$bp + aa$bn + 1e-5)) {\n    cat(\"hierarchy violated.\", fill=TRUE)\n    return(Inf)\n  }\n  if (any(aa$bp < -1e5)||any(aa$bn < -1e5)) {\n    cat(\"Non-negative of bp or bn violated.\", fill=TRUE)\n    return(Inf)\n  }\n  if (is.null(zz)) {\n    zz <- as.numeric(scale(compute.interactions.c(x, diagonal=aa$diagonal), center=TRUE, scale=FALSE))\n  }\n  if (is.matrix(zz)) zz <- as.numeric(zz)\n  if (is.null(xnum)) xnum <- as.numeric(x)\n  phat <- Compute.phat.c(xnum, zz, aa)\n  loss <- -sum(y*log(phat)) - sum((1-y)*log(1-phat))\n  pen <- lam.l1 * sum(aa$bp + aa$bn) + lam.l1 * sum(abs(aa$th))/2 + lam.l1 * sum(abs(diag(aa$th)))/2\n  pen <- pen + lam.l2 * (sum(aa$bp^2) + sum(aa$bn^2) + sum(aa$th^2))\n  loss + pen\n}\n\ncompute.interactions.c <- function(x, diagonal=TRUE) {\n  # Returns (uncentered) n by cp2 matrix of interactions.\n  # The columns of zz are in standard order (11), 12,13,14,...,(22),23,...\n  # z's (jk)th column is x_j * x_k\n  n <- nrow(x)\n  p <- ncol(x)\n  cp2 <- p * (p - 1) / 2\n  if (diagonal) {\n    cp2 <- cp2 + p\n    out <- .C(\"ComputeInteractionsWithDiagWithIndices\",\n              as.double(x),\n              as.integer(n),\n              as.integer(p),\n              z=rep(0, n * cp2),\n              i1=as.integer(rep(0, cp2)),\n              i2=as.integer(rep(0, cp2)), dupl = FALSE, PACKAGE=\"hierNet\")\n  }\n  else {\n    out <- .C(\"ComputeInteractionsWithIndices\",\n              as.double(x),\n              as.integer(n),\n              as.integer(p),\n              z=rep(0, n * cp2),\n              i1=as.integer(rep(0, cp2)),\n              i2=as.integer(rep(0, cp2)), dupl = FALSE, PACKAGE=\"hierNet\")\n  }\n  z <- matrix(out$z, n, cp2)\n  rownames(z) <- rownames(x)\n  if (is.null(colnames(x))) {\n    colnames(z) <- paste(out$i1, out$i2, sep=\":\")\n  }\n  else {\n    colnames(z) <- paste(colnames(x)[out$i1], colnames(x)[out$i2], sep=\":\")\n  }\n  z\n}\n\ncompute.full.interactions.c <- function(x) {\n  # Returns (uncentered) n by p^2 matrix of interactions.\n  # The columns of zz are in standard order 11,12,13,14,...,23,...\n  # z's (jk)th column is x_j * x_k\n  n <- nrow(x)\n  p <- ncol(x)\n  out <- .C(\"ComputeFullInteractions\",\n            as.double(x),\n            as.integer(n),\n            as.integer(p),\n            z=rep(0, n * p^2),\n            dupl = FALSE, PACKAGE=\"hierNet\")\n  matrix(out$z, n, p^2)\n}\n\n\nCompute.yhat.c <- function(xnum, zz, aa) {\n  # aa: list containing bp, bn, th, diagonal\n  # note: zz is the n by cp2 matrix, whereas z is the n by p^2 one.\n  p <- length(aa$bp)\n  n <- length(xnum) / p\n  stopifnot(n==round(n))\n  stopifnot(\"diagonal\" %in% names(aa))\n  if (aa$diagonal) stopifnot(length(zz) == n * (choose(p,2) + p))\n  else stopifnot(length(zz) == n * choose(p,2))\n\n  out <- .C(\"compute_yhat_zz_R\",\n            xnum,\n            as.integer(n),\n            as.integer(p),\n            zz,\n            as.integer(aa$diagonal),\n            as.double(aa$th),\n            aa$bp,\n            aa$bn,\n            yhat=rep(0, n),\n            DUP=FALSE, PACKAGE=\"hierNet\")\n  out$yhat\n}\n\nCompute.phat.c <- function(xnum, zz, aa) {\n  # aa: list containing b0, bp, bn, th\n  # note: zz is the n by cp2 matrix, whereas z is the n by p^2 one.\n  stopifnot(c(\"b0\",\"bp\",\"bn\",\"th\",\"diagonal\") %in% names(aa))\n  p <- length(aa$bp)\n  n <- length(xnum) / p\n  if (is.matrix(xnum)) xnum <- as.numeric(xnum)\n  stopifnot(n == round(n))\n  if (aa$diagonal) stopifnot(length(zz) == n * (choose(p,2) + p))\n  else stopifnot(length(zz) == n * choose(p,2))\n  #void compute_phat_zz_R(double *x, int *n, int *p, double *zz, int *diagonal,\n  #\t\t       double *b0, double *th, double *bp, double *bn, double *phat) {\n  out <- .C(\"compute_phat_zz_R\",\n            xnum,\n            as.integer(n),\n            as.integer(p),\n            zz,\n            as.integer(aa$diagonal),\n            as.double(aa$b0),\n            as.double(aa$th),\n            aa$bp,\n            aa$bn,\n            phat=rep(0, n),\n            DUP=FALSE, PACKAGE=\"hierNet\")\n  out$phat\n}\n\nggdescent.c <- function(x, xnum, zz, y, lam.l1, lam.l2, diagonal, rho, V, stepsize, backtrack=0.2, maxiter=100,\n                             tol=1e-5, aa=NULL, trace=1) {\n  # See ADMM4 pdf for the problem this solves.\n  # \n  # x, xnum, zz, y: data (note: zz is a length n*cp2 vector, not a matrix) xnum is x as a vector\n  # lam.l1: l1-penalty parameter\n  # lam.l2: l2-penalty parameter\n  # rho: admm parameter\n  # V: see ADMM4 pdf\n  # stepsize: step size to start backtracking with\n  # backtrack: factor by which step is reduced on each backtrack.\n  # maxiter: number of generalized gradient steps to take.\n  # tol: stop gg descent if change in objective is below tol.\n  # aa: initial estimate of (th, bp, bn)\n  # trace: how verbose to be\n  #\n  # void ggdescent_R(double *x, int *n, int *p, double *zz, int *diagonal, double *y, \n  #\t\t     double *lamL1, double*lamL2, double *rho, double *V, int *maxiter, \n  #\t\t     double *curth, double *curbp, double *curbn,\n  #\t\t     double *t, int *stepwindow, double *backtrack, double *tol, int *trace,\n  #\t\t     double *th, double *bp, double *bn) {\n  n <- length(y)\n  p <- ncol(x)\n  stepwindow <- 10\n  if (is.null(aa)) aa <- list(th=matrix(0,p,p), bp=rep(0,p), bn=rep(0,p))\n  out <- .C(\"ggdescent_R\",\n            xnum,\n            as.integer(n),\n            as.integer(p),\n            zz,\n            as.integer(diagonal),\n            y,\n            as.double(lam.l1),\n\t    as.double(lam.l2),\n            as.double(rho),\n            as.double(V),\n            as.integer(maxiter),\n            as.double(aa$th),\n            aa$bp,\n            aa$bn,\n            stepsize,\n            as.integer(stepwindow),\n            backtrack,\n            tol,\n            as.integer(trace),\n            th=rep(0, p*p),\n            bp=rep(0, p),\n            bn=rep(0, p),\n            DUP=FALSE, PACKAGE=\"hierNet\")\n  list(bp=out$bp, bn=out$bn, th=matrix(out$th, p, p))\n}\n\n\nhierNet.logistic <- function(x, y, lam, delta=1e-8, diagonal=TRUE, strong=FALSE, aa=NULL, zz=NULL, center=TRUE,\n                             stand.main=TRUE, stand.int=FALSE,\n                             rho=nrow(x), niter=100, sym.eps=1e-3,# ADMM params\n                             step=1, maxiter=2000, backtrack=0.2, tol=1e-5, # GG descent params\n                             trace=1) {\n  # Solves the logistic regression hiernet. Returns (b0, bp, bn, th)\n  this.call <- match.call()\n  n <- nrow(x)\n  p <- ncol(x)\n  stopifnot(y %in% c(0,1))\n  stopifnot(length(y) == n, lam >= 0, delta >= 0, delta <= 1)\n  stopifnot(!is.null(step) && !is.null(maxiter))\n  stopifnot(class(lam) == \"numeric\")\n  stopifnot(class(delta) == \"numeric\")\n  stopifnot(class(step) == \"numeric\", step > 0, maxiter > 0)\n  stopifnot(is.finite(x), is.finite(y), is.finite(lam), is.finite(delta))\n  lam.l1 <- lam * (1 - delta)\n  lam.l2 <- lam * delta\n  if (!center) \n    cat(\"WARNING: center=FALSE should almost never be used.  This option is available for special uses only.\", fill = TRUE)\n  x <- scale(x, center = center, scale = stand.main)\n  mx <- attr(x, \"scaled:center\")\n  sx <- attr(x, \"scaled:scale\")\n  if (is.null(aa)) aa <- list(b0=0, bp=rep(0, p), bn=rep(0, p), th=matrix(0, p, p), diagonal=diagonal)\n  if (is.null(zz)) {\n    if (trace > 0) cat(\"Computing zz...\", fill=TRUE)\n    zz <- compute.interactions.c(x, diagonal=diagonal)\n  }\n  if (is.matrix(zz)) {\n    zz <- scale(zz, center=center, scale=stand.int)\n    mzz <- attr(zz, \"scaled:center\")\n    szz <- attr(zz, \"scaled:scale\")\n    zz <- as.numeric(zz)\n  } else {\n    mzz <- szz <- NULL\n    #cat(\"Provided zz is not a matrix, so it's assumed to be already centered.\", fill = TRUE)\n  }\n  xnum <- as.numeric(x)\n  if (strong) {\n    # strong hierarchy -- use ADMM4 (logistic regression version)\n    stopifnot(is.numeric(rho), is.finite(rho))\n    out <- admm4.logistic(x, xnum, y, lam.l1, lam.l2, diagonal=diagonal, zz=zz,\n                          rho=rho, niter=niter, aa=aa, sym.eps=sym.eps, # ADMM params\n                          stepsize=step, backtrack=backtrack, maxiter=maxiter, tol=tol, # GG params\n                          trace=trace)\n    ii <- out$bp + out$bn == 0\n    # note out$th[ii, ] = 0 since weak hierarchy holds for sure\n    sumii <- sum(ii)\n    if (sumii > 0 && sumii < p) {\n      thr <- max(abs(out$th[!ii, ii]))\n      if (thr > 0) {\n        cat(\"  thr = \",thr, fill=TRUE)\n        if (thr > 1e-3)\n          warning(\"Had to change ADMM's 'th' by more than 0.001 to make strong hier hold! Increase niter (and/or rho). \")\n        aa$th[abs(aa$th) <= thr] <- 0\n      }\n    }\n  } else {\n    out <- ggdescent.logistic(xnum=xnum, zz=zz, y=y, lam.l1=lam.l1, lam.l2=lam.l2, diagonal=diagonal, rho=0, V=matrix(0,p,p),\n                                  stepsize=step, backtrack=backtrack, maxiter=maxiter,\n                                  tol=tol, aa=aa, trace=trace)\n  }\n  out$call <- this.call\n  out$lam <- lam\n  out$delta <- delta\n  out$type <- \"logistic\"\n  out$diagonal <- diagonal\n  out$strong <- strong\n  if (strong) {\n    # ADMM parameters:\n    out$rho <- rho\n    out$niter <- niter\n    out$sym.eps <- sym.eps\n  }\n  out$step <- step\n  out$maxiter <- maxiter\n  out$backtrack <- backtrack\n  out$tol <- tol\n  out$obj <- critf.logistic(x, y, lam.l1, lam.l2, out$b0, out$bp, out$bn, out$th)\n  out$mx <- mx\n  out$my <- 0\n  out$sx <- sx\n  out$mzz <- mzz\n  class(out) <- \"hierNet\"\n  return(out)\n}\n\n\nadmm4.logistic <- function(x, xnum, y, lam.l1, lam.l2, diagonal, zz=NULL, rho=10, niter, aa=NULL, sym.eps=1e-3, trace=1, ...) {\n  # Performs ADMM4 for logistic loss.\n  # Note: xnum is the matrix x as a numeric.  Both are passed to avoid having to call as.numeric too\n  # many times.\n  p <- ncol(x)\n  if (is.null(zz)) {\n    if (trace > 0) cat(\"Computing zz...\", fill=TRUE)\n    zz <- as.numeric(compute.interactions.c(x, diagonal=diagonal))\n  }\n  else if (class(zz) == \"matrix\") zz <- as.numeric(zz)\n  if (is.null(aa)) {\n    aa <- list(u=matrix(0, p, p),\n               th=matrix(0, p, p),\n               bp=rep(0, p),\n               bn=rep(0, p),\n               tt=matrix(0, p, p),\n               diagonal=diagonal)\n  }\n  if (is.null(aa$tt) || is.null(aa$u)) {\n    aa$tt <- 0.5 * (aa$th + t(aa$th))\n    aa$u <- matrix(0, p, p)\n  }\n  obj <- Objective.logistic(aa=aa, x=x, y=y, lam.l1=lam.l1, lam.l2=lam.l2, xnum=xnum, zz=zz, strong=TRUE, sym.eps=sym.eps)\n  for (i in seq(niter)) {\n    if (trace > 0) cat(i, \" \")\n    V <- aa$u - rho * aa$tt\n    gg <- ggdescent.logistic(xnum, zz, y, lam.l1=lam.l1, lam.l2=lam.l2, diagonal=diagonal, rho, V, trace=trace-1, aa=aa, ...)\n    aa$th <- gg$th\n    aa$bp <- gg$bp\n    aa$bn <- gg$bn\n    aa$tt <- (aa$th + t(aa$th)) / 2 + (aa$u + t(aa$u)) / (2 * rho)\n    aa$u <- aa$u + rho * (aa$th - aa$tt)\n    obj <- c(obj, Objective.logistic(aa=aa, x=x, y=y, lam.l1=lam.l1, lam.l2=lam.l2, xnum=xnum, zz=zz, strong=TRUE, sym.eps=sym.eps))\n    if (trace > 0) cat(obj[i+1], fill=TRUE)\n  }\n  if (max(abs(aa$th-t(aa$th))) > sym.eps)\n    cat(\"Attention: th not symmetric within the desired sym.eps.  Run ADMM for more iterations. And try increasing rho.\")\n  aa$obj <- obj\n  aa\n}\n\n\n\nggdescent.logistic <- function(xnum, zz, y, lam.l1, lam.l2, diagonal, rho, V, stepsize, backtrack=0.2, maxiter=100,\n                             tol=1e-5, aa=NULL, trace=1) {\n  # See ADMM4 pdf and logistic.pdf for the problem this solves.\n  # \n  # xnum, zz, y: data (note: zz is a length n*cp2 vector, not a matrix) xnum is x as a (n*p)-vector\n  # lam.l1: l1-penalty parameter\n  # lam.l2: l2-penalty parameter\n  # rho: admm parameter\n  # V: see ADMM4 pdf\n  # stepsize: step size to start backtracking with\n  # backtrack: factor by which step is reduced on each backtrack.\n  # maxiter: number of generalized gradient steps to take.\n  # tol: stop gg descent if change in objective is below tol.\n  # aa: initial estimate of (b0, th, bp, bn)\n  # trace: how verbose to be\n  #\n  #void ggdescent_logistic_R(double *x, int *n, int *p, double *zz, int * diagonal, double *y, \n  #\t\t\t     double *lamL1, double *lamL2, double *rho, double *V, int *maxiter, \n  #\t\t\t     double *curb0, double *curth, double *curbp, double *curbn,\n  #\t\t\t     double *t, int *stepwindow, double *backtrack, double *tol, int *trace,\n  #\t\t\t     double *b0, double *th, double *bp, double *bn) {\n  n <- length(y)\n  p <- length(xnum) / n\n  stopifnot(p == round(p))\n  if (diagonal) stopifnot(length(zz) == n * (choose(p,2)+p))\n  else stopifnot(length(zz) == n * choose(p,2))\n  stepwindow <- 10\n  if (is.null(aa)) aa <- list(b0=0, th=matrix(0,p,p), bp=rep(0,p), bn=rep(0,p))\n  out <- .C(\"ggdescent_logistic_R\",\n            xnum,\n            as.integer(n),\n            as.integer(p),\n            zz,\n            as.integer(diagonal),\n            as.double(y), # convert from integer to double\n            as.double(lam.l1),\n            as.double(lam.l2),\n            as.double(rho),\n            as.double(V),\n            as.integer(maxiter),\n            as.double(aa$b0),\n            as.double(aa$th),\n            aa$bp,\n            aa$bn,\n            as.double(stepsize),\n            as.integer(stepwindow),\n            as.double(backtrack),\n            as.double(tol),\n            as.integer(trace),\n            b0=as.double(0),\n            th=rep(0, p*p),\n            bp=rep(0, p),\n            bn=rep(0, p),\n            DUP=FALSE, PACKAGE=\"hierNet\")\n  list(b0=out$b0, bp=out$bp, bn=out$bn, th=matrix(out$th, p, p))\n}\n\n\nADMM4.Lagrangian <- function(aa, xnum, zz, y, lam.l1, lam.l2, diagonal, rho) {\n  # aa: list with (th, bp, bn, tt, u)\n  # zz is a vector not a matrix\n  if (aa$diagonal == FALSE)\n    if (any(abs(diag(aa$th)) > 1e-8)) {\n      cat(\"Diagonal of Theta is nonzero.\", fill=TRUE)\n      return(Inf)\n    }\n  if (max(aa$tt-t(aa$tt)) > 1e-8) {\n    cat(\"Theta is not symmetric.\", fill=TRUE)\n    return(Inf)\n  }\n  if (any(rowSums(abs(aa$th)) > aa$bp + aa$bn + 1e-5)) {\n    cat(\"hierarchy violated.\", fill=TRUE)\n    return(Inf)\n  }\n  if (any(aa$bp < -1e-5)||any(aa$bn < -1e-5)) {\n    cat(\"Non-negative of bp or bn violated.\", fill=TRUE)\n    return(Inf)\n  }\n  if (diagonal == FALSE)\n    if (any(abs(diag(aa$th)) > 1e-5)) {\n      cat(\"Zero diagonal violated.\", fill=TRUE)\n      return(Inf)\n    }\n\n  V <- aa$u - rho * aa$tt\n\n  r <- y - Compute.yhat.c(xnum, zz, aa)\n  admm <- sum(aa$u*(aa$th-aa$tt)) + (rho/2) * sum((aa$th-aa$tt)^2)\n  #admm <- sum(V*aa$th) + (rho/2) * sum(aa$th^2) + (rho/2)*sum(aa$tt^2) - sum(aa$u*aa$tt)\n  pen <- lam.l1 * (sum(aa$bp + aa$bn) + sum(abs(aa$th))/2)\n  pen <- pen + lam.l2 * (sum(aa$bp^2) + sum(aa$bn^2) + sum(aa$th^2))\n  sum(r^2)/2 + pen + admm\n}\n\n\npredict.hierNet.logistic <- function(object, newx, newzz=NULL, ...) {\n  predict.hierNet(object, newx, newzz, ...)\n}\n\ncritf.logistic <- function(x, y, lam.l1, lam.l2, b0, bp, bn, th) {\n  yhat <- b0 + x %*% (bp - bn) + 0.5 * diag(x %*% th %*% t(x))\n  p <- 1 / (1 + exp(-yhat))\n  val <- -sum(y * log(p) + (1 - y) * log(1 - p)) \n  val <- val + lam.l1 * sum(bp + bn) + lam.l1 * sum(abs(th))/2 + lam.l1 * sum(abs(diag(th)))/2\n  val <- val + lam.l2 * (sum(bp^2) + sum(bn^2) + sum(th^2))\n  return(val)\n}\n\ntwonorm <- function(x) {sqrt(sum(x * x))}\n\nhierNet.logistic.path <- function (x, y, lamlist=NULL, delta=1e-8, minlam=NULL, maxlam=NULL, flmin=.01, nlam=20, \n                                   diagonal=TRUE, strong=FALSE, aa=NULL, \n                                   zz=NULL, stand.main=TRUE, stand.int=FALSE,\n                                   rho=nrow(x), niter=100, sym.eps=1e-3,# ADMM params\n                                   step=1, maxiter=2000, backtrack=0.2, tol=1e-5, # GG params\n                                   trace=0) {\n  this.call=match.call()\n  stopifnot(y %in% c(0, 1))\n  x <- scale(x, center=TRUE, scale=stand.main)\n  mx <- attr(x, \"scaled:center\")\n  sx <- attr(x, \"scaled:scale\")\n  \n  if (is.null(maxlam)) {\n    if (!is.null(minlam)) stop(\"Cannot have maxlam=NULL if minlam is non-null.\")\n    maxlam <- max(abs(t(x) %*% y))\n    minlam <- maxlam * flmin\n  }\n  if (is.null(minlam)) minlam <- maxlam * flmin\n  if (is.null(lamlist))\n    lamlist <- exp(seq(log(maxlam), log(minlam), length=nlam))\n  nlam <- length(lamlist)\n  \n  if (is.null(zz)) \n    zz <- compute.interactions.c(x, diagonal=diagonal)\n  else stopifnot(is.matrix(zz))\n  zz <- scale(zz, center=TRUE, scale=stand.int)\n  mzz <- attr(zz, \"scaled:center\")\n  szz <- attr(zz, \"scaled:scale\")\n  zz <- as.numeric(zz)\n  p <- ncol(x)\n  cp2 <- choose(p, 2)\n  b0 <- rep(NA, nlam)\n  bp <- bn <- matrix(NA, nrow=p, ncol=nlam)\n  th <- array(NA, c(p, p, nlam))\n  obj <- rep(NA, nlam)\n  aa <- NULL\n  for (i in seq(nlam)) {\n    cat(c(\"i,lam=\", i, round(lamlist[i],2)), fill=TRUE)\n    aa <- hierNet.logistic(x, y, lam=lamlist[i], delta=delta, diagonal=diagonal, strong=strong, \n                           aa=aa, zz=zz, stand.main=FALSE, stand.int=FALSE,\n                           rho=rho, niter=niter, sym.eps=sym.eps,\n                           step=step, maxiter=maxiter, backtrack=backtrack, tol=tol, \n                           trace=trace)\n    b0[i] <- aa$b0\n    bp[, i] <- aa$bp\n    bn[, i] <- aa$bn\n    th[, , i] <- aa$th\n    obj[i] <- aa$obj\n  }\n  dimnames(bp) <- dimnames(bn) <- list(as.character(1:p), NULL)\n  dimnames(th) <- list(as.character(1:p), as.character(1:p), NULL)\n  out <- list(b0=b0, bp=bp, bn=bn, th=th, obj=obj, lamlist=lamlist, delta=delta,\n              mx=mx, my=0, sx=sx, mzz=mzz, szz=szz,\n              type=\"logistic\", diagonal=diagonal, strong=strong,\n              step=step, maxiter=maxiter, backtrack=backtrack, tol=tol,\n              call=this.call)   \n  if (strong) {\n    # ADMM parameters:\n    out$rho <- aa$rho\n    out$niter <- niter\n    out$sym.eps <- sym.eps\n  }\n  class(out) <- \"hierNet.path\"\n  out\n}\n\nbalanced.folds <- function(y, nfolds=min(min(table(y)), 10)) {\n  totals <- table(y)\n  fmax <- max(totals)\n  nfolds <- min(nfolds, fmax)\n  # makes no sense to have more folds than the max class size\n  folds <- as.list(seq(nfolds))\n  yids <- split(seq(y), y)\n  # nice we to get the ids in a list, split by class\n  ###Make a big matrix, with enough rows to get in all the folds per class\n  bigmat <- matrix(NA, ceiling(fmax/nfolds) * nfolds, length(totals))\n  for(i in seq(totals)) {\n    bigmat[seq(totals[i]), i] <- sample(yids[[i]])\n  }\n  smallmat <- matrix(bigmat, nrow = nfolds)       # reshape the matrix\n  ### Now do a clever sort to mix up the NAs\n  smallmat <- permute.rows(t(smallmat))   ### Now a clever unlisting\n  # the \"clever\" unlist doesn't work when there are no N\n  #       apply(smallmat, 2, function(x)\n  #        x[!is.na(x)])\n  res <-vector(\"list\", nfolds)\n  for(j in 1:nfolds) {\n    jj <- !is.na(smallmat[, j])\n    res[[j]] <- smallmat[jj, j]\n  }\n  return(res)\n}\n\npermute.rows <-function(x) {\n  dd <- dim(x)\n  n <- dd[1]\n  p <- dd[2]\n  mm <- runif(length(x)) + rep(seq(n) * 10, rep(p, n))\n  matrix(t(x)[order(mm)], n, p, byrow = TRUE)\n}\n\nhierNet.cv <- function(fit, x, y, nfolds=10, folds=NULL, trace=0) {\n  this.call <- match.call()\n  stopifnot(class(fit) == \"hierNet.path\")\n  if(fit$type==\"gaussian\"){errfun=function(y,yhat){(y-yhat)^2}} \n  if(fit$type==\"logistic\"){errfun=function(y,yhat){1*(y!=yhat)}} \n  n <- length(y)\n  if(is.null(folds)) {\n    folds <- split(sample(1:n), rep(1:nfolds, length = n))\n  }\n  else {\n    stopifnot(class(folds)==\"list\")\n    nfolds <- length(folds)\n  } \n  lamlist=fit$lamlist\n\n  # get whether fit was standardized based on fit$sx and fit$szz...\n  if (is.null(fit$mx)) stop(\"hierNet object was not centered.  hierNet.cv has not been written for this (unusual) case.\")\n  stand.main <- !is.null(fit$sx)\n  stand.int <- !is.null(fit$szz)\n  \n  n.lamlist <- length(lamlist)        ### Set up the data structures\n  size <- double(n.lamlist)\n  err2=matrix(NA,nrow=nfolds,ncol=length(lamlist))\n  for(ii in 1:nfolds) {\n    cat(\"Fold\", ii, \":\")\n    if(fit$type==\"gaussian\"){\n      a <- hierNet.path(x[-folds[[ii]],],y=y[-folds[[ii]]], \n                        lamlist=lamlist, delta=fit$delta, diagonal=fit$diagonal, strong=fit$strong, trace=trace,\n                        stand.main=stand.main, stand.int=stand.int,\n                        rho=fit$rho, niter=fit$niter, sym.eps=fit$sym.eps, # ADMM parameters (which will be NULL if strong=F)\n                        step=fit$step, maxiter=fit$maxiter, backtrack=fit$backtrack, tol=fit$tol) # GG descent params\n      \n      yhatt=predict.hierNet(a,newx=x[folds[[ii]],])\n    }\n    if(fit$type==\"logistic\"){\n      a <- hierNet.logistic.path(x[-folds[[ii]],],y=y[-folds[[ii]]], \n                                 lamlist=lamlist, delta=fit$delta, diagonal=fit$diagonal, strong=fit$strong,\n                                 trace=trace, stand.main=stand.main, stand.int=stand.int,\n                                 rho=fit$rho, niter=fit$niter, sym.eps=fit$sym.eps, # ADMM parameters (which will be NULL if strong=F)\n                                 step=fit$step, maxiter=fit$maxiter, backtrack=fit$backtrack, tol=fit$tol) # GG descent params                                 \n      yhatt=predict.hierNet.logistic(a,newx=x[folds[[ii]],])$yhat\n    }\n    \n    temp=matrix(y[folds[[ii]]],nrow=length(folds[[ii]]),ncol=n.lamlist)\n    err2[ii,]=colMeans(errfun(yhatt,temp))\n    cat(\"\\n\")\n  }\n  errm=colMeans(err2)\n  errse=sqrt(apply(err2,2,var)/nfolds)\n  o=which.min(errm)\n  lamhat=lamlist[o]\n  oo=errm<= errm[o]+errse[o]\n  lamhat.1se=lamlist[oo & lamlist>=lamhat][1]\n  \n  nonzero=colSums(fit$bp-fit$bn!=0) + apply(fit$th!=0, 3, function(a) sum(diag(a)) + sum((a+t(a)!=0)[upper.tri(a)]))\n  obj <- list(lamlist=lamlist, cv.err=errm,cv.se=errse,lamhat=lamhat, lamhat.1se=lamhat.1se,\n             nonzero=nonzero, folds=folds,\n             call = this.call)\n  class(obj) <- \"hierNet.cv\"\n  obj\n}\n\nplot.hierNet.cv <- function(x, ...) {\n  par(mar = c(5, 5, 5, 1))\n  yrang=range(c(x$cv.err-x$cv.se,x$cv.err+x$cv.se))\n  plot(log(x$lamlist), x$cv.err, xlab=\"log(lambda)\",\n       ylab = \"Cross-validation Error\", type=\"n\",ylim=yrang)\n  axis(3, at = log(x$lamlist), labels = paste(x$nonzero), srt = 90, adj = 0)\n  mtext(\"Number of features\", 3, 4, cex = 1.2)\n  axis(2, at = c(0, 0.2, 0.4, 0.6, 0.8))\n  error.bars(log(x$lamlist), x$cv.err - x$cv.se, x$cv.err + x$cv.se, width = 0.01, col = \"darkgrey\")\n  points(log(x$lamlist), x$cv.err, col=2, pch=19)\n  abline(v=log(x$lamhat), lty=3)\n  abline(v=log(x$lamhat.1se), lty=3)\n  invisible()\n}\n\nerror.bars <-function(x, upper, lower, width = 0.02, ...) {\n  xlim <- range(x)\n  barw <- diff(xlim) * width\n  segments(x, upper, x, lower, ...)\n  segments(x - barw, upper, x + barw, upper, ...)\n  segments(x - barw, lower, x + barw, lower, ...)\n  range(upper, lower)\n}\n\nhierNet.varimp <- function(fit,x,y, ...) {\n  # NOTE: uses 0.5 cutoff for logistic case\n  lam=fit$lam\n  if(fit$type==\"gaussian\"){errfun=function(y,yhat){(y-yhat)^2}}\n  if(fit$type==\"logistic\"){\n    errfun=function(y,yhat){\n      term1=y*log(yhat);term1[yhat==0]=0\n      term2=(1-y)*log(1-yhat);term2[yhat==1]=0\n      val=-sum(term1+term2)\n      return(val)\n    }}\n  yhat=predict(fit,x)\n  rss=sum(errfun(y,yhat))\n  varsum=fit$bp-fit$bn+rowSums(abs(fit$th))\n  oo=which(abs(varsum)>1e-6)\n  imp=rss2=rep(NA,ncol(x))\n  for(j in oo){\n    cat(j)\n    fit0=fit;fit0$bp=fit$bp[-j];fit0$bn=fit$bn[-j];fit0$th=fit$th[-j,-j]\n    if(fit$type==\"gaussian\"){ fit2=hierNet(x[,-j],y,lam,delta=fit$delta,diagonal=fit$diagonal,aa=fit0)}\n    if(fit$type==\"logistic\"){ fit2=hierNet.logistic(x[,-j],y,lam,delta=fit$delta,diagonal=fit$diagonal,aa=fit0)}\n    yhat2=predict(fit2,x[,-j])\n    rss2[j]=sum(errfun(y,yhat2))\n    imp[j]=(rss2[j]-rss)/rss2[j]\n  }\n  imp[-oo]=0\n  res=cbind(1:ncol(x),round(imp,3))\n  ooo=order(-imp)\n  dimnames(res)=list(NULL,c(\"Predictor\",\"Importance\"))\n  cat(\"\",fill=T)\n  return(res[ooo,])\n}\n",
    "created" : 1457259497237.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2555571906",
    "id" : "49A1A527",
    "lastKnownWriteTime" : 1457292048,
    "last_content_update" : 1457292048,
    "path" : "D:/_R projects/hierNet/R/funcs.R",
    "project_path" : "R/funcs.R",
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}